#### Ниже статья в которой автора от первого лица  рассказывает про то как работать с Git.

[Первоисточник Habr.ru (КЛИК!)](https://habr.com/ru/post/588801/)

![](git.jpeg)

Cодержание:
===========================

1. Введение;

2. Установка Git;

3. Структура директории .git/;

4. Самые распространенные команды в Git;

5. Работа с историей;

6. Ветвление в Git;

7. Примеры ведения истории проекта;

8. Заключение.

***

## Введение

Привет, Хабр! Меня зовут Егор, я занимаюсь разработкой мобильных приложений на Flutter. Это моя первая работа в сфере IT, и как подобает начинающим, я столкнулся с проблемой изучения систем контроля версий. В данной публикации я хочу поделиться приобретенными знаниями и подробно рассмотреть одну из таких систем, а именно Git. Итак, начнем...

>“Whoah, I’ve just read this quick tuto about git and oh my god it is cool. I feel now super comfortable using it, and I’m not afraid at all to break something.” — said no one ever.

Не так страшен чёрт, как его малюют. Хотя, как мне кажется, это не касается Git. Так или иначе многие сталкиваются с необходимостью обучиться грамотной работе с этим инструментом. Несмотря на обилие информации и туториалов, это задача является не самой тривиальной. Исходя из своего опыта, могу сделать вывод: необходимо изучить самые разные ресурсы, прежде чем наступит понимание.

Полагаю, все дело в том, что изучение Git - комплексная тема, и охватить ее в одной статье, чтобы быстренько освоить азы и тут же применить знания на практике, несколько сложно.

Тем не менее, я бы хотел дополнить просторы интернета очередной статьей о Git. Постараюсь изложить все таким образом, как если бы у меня была возможность объяснить все самому себе из прошлого. Как следует из названия, я расскажу о Git очень коротко; а точнее о возможностях, которые он нам предоставляет.

Перед тем, как говорить про какую-либо конкретную систему контроля версий, необходимо понимать, что это такое и какими они бывают.

Система контроля версий - это программное обеспечение, помогающее разработчикам управлять состоянием исходного кода на протяжение всей разработки. Другими словами, это система, которая записывает ваши изменения в файл и позже позволяет откатиться к более ранней версии проекта.

Системы контроля версий можно разделить на две группы:

* Централизованные системы контроля версий;
* Распределенные системы контроля версий.

Распределенная система контроля версий - это система, при которой копия репозитория может храниться на машине у каждого разработчика, что значительно снижает риск потерять результат работы над проектом. Примером таких систем могут быть: Git, Mercurial, Bazaar.

Git является распределенной системой контроля версий, разработанной Линусом Торвальдсом для управления разработкой ядра Linux. На данный момент Git завоевал огромную популярность в IT сообществе и, как следствие, его часто можно встретить в стеке технологий различных компаний.

Далее я расскажу про структуру Git репозитория и как его завести. Познакомлю вас с основными, наиболее популярными командами в Git. Также вы узнаете о том, как инспектировать историю своего проекта и как откатить его до определенной точки. И, в заключение, я слегка затрону тему ветвления.

---

## 1. Установка Git

Прежде чем мы продолжим, вам необходимо установить Git.

Ниже я представлю краткую инструкцию к установке, но вы также можете пройти по этой ссылке на официальный источник и разобраться в этом самостоятельно.

* Mac OS:

|Если вы используете менеджер пакетов HomeBrew,
Вы можете выполнить следующую команду: | В противном случае вам достаточно ввести: |
| ------------- | ------------- |
| brew install git  | git --version |

* Windows. Перейдите по [ссылке](https://git-scm.com/download/win)  и скачайте Git соответствующий архитектуре вашего процессора (32 или 64-bit) и установите его.

* Linux. Перейдите по [ссылке](https://git-scm.com/download/linux) для более подробной инструкции.

<font color="red">Установка на Linux зависит от дистрибутива который вы используете:</font>

|Debian/Ubuntu: | Fedora: |
| ------------- | ------------- |
|  apt-get install git  | yum install git |

## 2. Структура директории .git/

Как правило, ваша работа с Git будет начинаться с того, что вам потребуется проинициализировать Git директорию в своем проекте. Это делается с помощью команды:

> git init

Ее необходимо ввести в корне вашего проекта. Это создаст в текущем каталоге новый подкаталог .git со следующим содержанием:

![](2.png)

В данной директории будет содержаться вся конфигурация Git и история проекта. При желании можно править эти файлы вручную, внося необходимые изменения в историю проекта.

1. config

В данном файле содержатся настройки Git репозитория. Например, здесь можно хранить email и имя пользователя.

2. description

Данный файл предназначен для GitWeb и содержит в себе информацию о проекте (название проекта и его описание). GitWeb - это веб интерфейс, написанный для просмотра Git репозитория используя веб-браузер. Если вы не пользуетесь GitWeb, то это не столь важно.

3. hooks

В этом каталоге Git предоставляет набор скриптов, которые могут автоматически запускаться во время выполнения git команд. В некоторых случаях это значительно упрощает разработку. Например, вы можете написать скрипт, который будет редактировать сообщение коммита согласно вашим требованиям.

4. info - exclude

Каталог info содержит файл exclude, в котором можно указывать любые файлы, и Git не станет добавлять их в свою историю. Это почти то же самое что и .gitingnore (возможно вы сталкивались с ним. Его можно найти в корневом каталоге вашего проекта), за тем исключением, что exclude не сохраняется в истории проекта, и вы не сможете им поделиться с другими.

5. refs

Каталог refs хранит в себе копию ссылок на объекты коммитов в локальных и удаленных ветках.

6. logs

Каталог logs хранит в себе историю проекта для всех веток в вашем проекте.

7. objects

Каталог objects хранит в себе BLOB объекты, каждый из которых проиндексирован уникальным SHA.

8. index

Промежуточная область с метаданными, такими как временные метки, имена файлов, а также SHA файлов, которые уже упакованы Git. В эту область попадают файлы, над которыми вы работали, при выполнение команды git add.

9. HEAD

Файл содержит ссылку на текущую ветку, в которой вы работаете

10. ORIG_HEAD

Каждый раз во время слияния в этот файл попадает SHA ветки, с которой проводилось слияние

11. FETCH_HEAD

Файл хранит в себе ссылки в виде SHA на ветки, которые участвовали в git fetch

12. MERGE_HEAD

Файл хранит в себе ссылки в виде SHA на ветки, которые участвовали в git merge

13. COMMIT_EDITMSG

Файл содержит в себе последнее введенное вами сообщение коммита

---

## 3. Самые распространенные команды в Git

![](3.png)

При работе с системами контроля версий разработчики сталкиваются с определенной, повторяющейся последовательностью действий. Оно и понятно, ведь, по сути, если не брать в расчет возможности Git для управления состоянием проекта и прочие плюшки, то как правило ваша работа ограничена рядом действий:

1. Внести изменения в проект;

2. Добавить изменения в индекс(staging area) - `git add` (таким образом вы сообщаете Git какие именно изменения должны быть занесены в историю.)

2. Закоммитить изменения - `git commit` (сохранить изменения в историю проекта)

3. Запушить - `git push` (отправить результаты работы на удаленный сервер, чтобы другие разработчики тоже имели к ним доступ)

Итак, разберемся в этом подробнее. Проинициализировав Git репозиторий, вы начинаете вносить какие-то изменения в проект. Предположим, что вы создали файл `hello_world.txt` и работаете над его редактированием.

Введем `git status` и увидим следующее:

    On branch master

    No commits yet

    Untracked files:

    (use "git add <file>..." to include in what will be committed)

        hello_world.txt


Команда git status отображает состояние директории и индекса(staging area). Это позволяет определить, какие файлы в проекте отслеживаются Git, а также какие изменения будут включены в следующий коммит.

Так как вы создали новый файл, Git определяет его как неотслеживаемый, и тут же подсказывает, что делать дальше:

        use “git add <file>...” to include in what will be committed

Так и поступим: 

`git add hello_world.txt`      

        On branch master
        No commits yet
        Changes to be commited:
	    (use "git rm --cached <file>..." to unstage)
        new file: hello_world.txt

Файл добавлен в индекс. Теперь можно закоммитить внесенные изменения и оставить небольшое описание. Делается это командой:

`git commit -m ‘first commit`

Готово! Мы сделали наш первый коммит! Далее добавим в наш файл строку “Hello, World!”, и снова проверим git status:

    On branch master 

    Changes not staged for commit:

    (use "git add <file>..." to update what will be committed)

    (use "git restore <file>..." to discard changes in working directory)

    no changes added to commit (use "git add" and/or "git commit -a")

Теперь Git сообщает, что у нас есть измененный файл `hello_world.txt.` И теперь нам сново нужно добавить его в индекс и затем закоммитить.

Что ж, мы научились записывать и хранить изменения на своей машине, теперь нам нужно отправить версию нашей истории на удаленный сервер. В данном примере я воспользуюсь репозиторием на [Github](https://github.com/)

Для начала вам нужно создать удаленный репозиторий. Как это реализовать в случае с GitHub подробно описано [тут](https://docs.github.com/en/get-started/quickstart/create-a-repo)

Далее необходимо добавить удаленный репозиторий в Git:

`git remote add <remote_name> <remote_repo_url>`

Эта команда сопоставит удаленное хранилище с ссылкой на локальный репозиторий. С этого момента можно обращаться к удаленному репозиторию через эту ссылку. Например:

`git remote add origin https://github.com/user/hello_world.git`

В данном случае “origin” является коротким именем для удаленного репозитория, на которое он будет ссылаться. Вы можете выбрать совершенно любое имя - это не важно. “origin” это просто стандартное соглашение.

Осталось дело за малым - отправить результат нашей работы в репозиторий. Делается это следующим образом:

`git push origin`

Готово! Теперь история изменений вашего проекта будет храниться в удаленном репозитории.

---

## 4. Работа с историей

![](4.png)

Итак, как записывать, сохранять и отправлять изменения в удаленное хранилище мы разобрались.

Настало время поговорить о том, как управлять историей проекта. А именно как просматривать изменения и как откатить проект до определенной точки.

Для инспектирования истории в Git предусмотрен определенный ряд команд, рассмотрим несколько из них:

- **git log**

- **git show**

- **git reflog**

- **git reset**

- **git log**

1. git log

Данная команда предназначена для отображения всей вашей истории. Она может быть весьма удобна, если вам понадобилось узнать, какие изменения вы вносили ранее. Или если вам нужно откатиться до определенного места в истории, либо если есть нужда её отредактировать.

Если ввести `git log` без каких либо параметров, выглядит это примерно так:

`git log`

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

    fourth commit 

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

    third commit

    commit dslf4453lk34jk34k3h5g34u6m5n75j7kj3l345k 

Date: Fri Jul 16 13:22:27 2021 +0300

    second commit

    commit h4k4o5jk2lhkl234jkl6nkg6j4lh4gjbh6ll45k4

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:21:32 2021 +0300

    first commit

`git log` имеет огромное множество дополнительных параметров, которые будут влиять на вывод в консоль. Вам предоставляется выбор на любой вкус.

Хотите просмотреть последние три коммита? Пожалуйста:

`git log -3`

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

    third commit

    commit dslf4453lk34jk34k3h5g34u6m5n75j7kj3l345k 

    Date: Fri Jul 16 13:22:27 2021 +0300

    second commit

    commit h4k4o5jk2lhkl234jkl6nkg6j4lh4gjbh6ll45k4

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:21:32 2021 +0300

    first commit

Есть необходимость вывести все в одну линию? Запросто:

`git log --oneline`

    957e113 (HEAD -> main) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit

Так можно продолжать до бесконечности, поэтому я оставлю [ссылочку](https://git-scm.com/docs/git-log#:~:text=shown.-,OPTIONS,---follow), перейдя по которой, вы сможете с ними подробней ознакомиться.

2. git show

Команда `git show` используется для отображения полной информации о любом объекте в Git, будь то коммит или ветка. По умолчанию git show отображает информацию коммита, на который в данный момент времени указывает HEAD.

Для удобства работы `git show` оснащен рядом дополнительных параметров, некоторые из них мы рассмотрим ниже.

Итак, если ввести `git show`, мы получим следующий результат:

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

    fourth commit 

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1,2 +1,3 @@

    Hello world!

    Bye, bye!

    +See you soon!

Здесь представлена полная информация о последнем коммите, а также какие именно изменения он в себя включает.

Мы также можем вывести диапазон из указанных коммитов. Диапазон указывается полуоткрытым интервалом, содержащим id коммитов, не включая первый элемент. Выглядит это следующим образом:

`git show 349de9d..957e113`

    commit 957e1132f57d83§dbd402faf3c858cf5ba8b335f (HEAD -> master)

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:25:21 1021 +0300

    fourth commit 

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1,2 +1,3 @@

    Hello world!

    Bye, bye!

   +See you soon!

    commit ekd53dkcld4dkf334r3r3sefio5dk6kfl54dkf53 

    Author: egor <egor@mail.ru>

    Date: Fri Jul 16 13:22:25 2021 +0300

    third commit

    diff --git a/hello_world.txt b/hello_world.txt

    index cd08755..b402110 100644

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1 +1,2 @@

    Hello world!

   +Bye, bye!

Для более лаконичного вывода, можно воспользоваться командой:

`git show --oneline`

    957e113 (HEAD -> master) fourth commit

    diff --git a/hello_world.txt b/hello_world.txt

    index b402110..d49b5d7 10044

    --- a/hello_world.txt

    +++ b/hello_world.txt

    @@ -1,2 +1,3 @@

    Hello world!

    Bye, bye!

    +See you soon!

Таким образом, мы сократим id коммита, а также исключим авторство и дату коммита.

Подробнее с командой `git show` и с её параметрами можно ознакомиться перейдя по [ссылке](https://git-scm.com/docs/git-show).

3. git reflog

Эта команда выводит упорядоченный список коммитов, на которые указывал HEAD. Грубо говоря, она отображает историю всех ваших перемещений по проекту.

Основное преимущество этой команды заключается в том, что если вы вдруг случайно удалили часть истории или откатились назад, вы сможете проинспектировать момент утраты нужной вам информации и откатиться обратно.

Это возможно за счет того, что `git reflog` хранит свою информацию на вашей машине отдельно от коммитов, поэтому при удалении чего-либо в истории, в сможете это найти в `git reflog`.

Вывод этой команды выглядит следующим образом:

    957e113 (HEAD -> master) HEAD@{5}: commit: fourth commit

    ekd53dk HEAD@{6}: commit: third commt

    dslf445 HEAD@{7}: commit: second commit

    h4k4o5j HEAD@{8}: commit (intial): first commit 

4. git reset

![](4.1.jpeg)

Теперь давайте рассмотрим очень полезную команду `git reset`. Она позволяет откатить проект до определенной точки.

Эту команду можно использовать с тремя параметрами:

* `git reset --soft <commit>`

* `git reset --mixed <commit>`

* `git reset --hard <commit>`

Рассмотрим их по порядку. Для этого сначала давайте вспомним, что такое index. Как я упоминал ранее, index - это временный файл, который фиксирует структуру Git проекта в определенный момент времени. Это важная деталь сейчас, поскольку команда `git reset` в зависимости от параметра прокидывает нас в истории проекта с соответствующими состояниями индекса.



>В случае с --soft, содержимое вашего индекса, а также рабочей директории, остается неизменным. Это значит, что если мы откатимся назад на пару коммитов, мы изменим ссылку указателя HEAD на указанный коммит и все изменения, которые были до этого внесены, окажутся в индексе.

>При использовании параметра --mixed, мы опять-таки изменим ссылку указателя HEAD, но все предыдущие изменения в индекс не попадут, а будут отслеживаться как не занесенные в индекс. Это дает возможность внести в индекс только те изменения, которые нам необходимы, что довольно удобно!

>Если использовать команду git reset с параметром --hard, мы снова изменим ссылку указателя HEAD, но все предыдущие изменения не попадут ни в индекс, ни в зону отслеживаемых файлов. Это значит, что мы полностью сотрем все изменения, которые вносили ранее. Это также удобно, если вы знаете, что вам больше не пригодится ваша предыдущая работа над проектом.

Давайте вернемся к нашему репозиторию и рассмотрим следующий пример:

`git log --oneline` 

    957e113 (HEAD -> master) fourth commit

    ekd53dk third commit

    dslf445 second commit

    h4k4o5j first commit

Итак, в ходе нашей работы, мы сделали четыре коммита. Предположим, что мы хотим откатить проект до второго коммита. Давайте посмотрим, как это будет происходить, используя разные параметры:

`git reset --soft 349de9d`

Далее, проверим индекс:

`git status`

    On branch master

    Changes to be committed:

    (use "git restore --staged <file>..." to unstage)

        modified: hello_world.txt

И снова `git log --oneline`:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit

Как и ожидалось, указатель HEAD переместился на второй коммит, а состояние индекса осталось неизменным.

Теперь повторим наши действия, но уже с параметром `--mixed`:

`git reset --mixed 349de9d`

Проверим `git status`:

    On branch master

    Changes not staged for commit:

    (use "git add <file>..." to update what will be committed)

    (use "git restore <file>..." to discard changes in working directory)

        modified: hello_world.txt

А также `git log --oneline`:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit
    
В данном случае, указатель снова переместился на второй коммит, но предыдущие изменения попали в зону отслеживаемых файлов. Это значит, что теперь мы можем решить - оставить эти изменения, добавив их в индекс, либо избавиться от них.

И в заключении повторим ту же последовательность действий с параметром `--hard`.

`git reset --hard 349de9d`

Снова проверяем `git status`:

    On branch master

    nothing to commit, working tree clean

И `git log --oneline`:

    dslf445 (HEAD -> master) second commit

    h4k4o5j first commit

Здесь указатель HEAD переместился на второй коммит, а все предыдущие изменения были стерты, что видно по пустому индексу и зоне отслеживаемых файлов.

И если посмотреть сейчас содержимое файла, то мы увидим единственную строку “Hello, world!”, которую мы с вами добавляли в файл во втором коммите.

---

## 5. Ветвление в Git

## 6. Примеры ведения истории проекта

## 7.Заключение







